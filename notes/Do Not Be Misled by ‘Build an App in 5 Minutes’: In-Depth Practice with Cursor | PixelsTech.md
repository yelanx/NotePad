> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.pixelstech.net](https://www.pixelstech.net/article/1734488862-do-not-be-misled-by-%e2%80%98build-an-app-in-5-minutes%e2%80%99%3a-in-depth-practice-with-cursor?lang=chinese)

> In August this year, I tried out Cursor and was thoroughly impressed, prompting me to write an introd......

今年八月，我尝试了 [Cursor](https://www.cursor.com/)，并且印象深刻，促使我撰写了关于它的[一篇介绍性文章](https://zhuanlan.zhihu.com/p/716192597)。不久之后，我将我的日常工作环境完全从 **GitHub Copilot + JetBrains** 转换到了 **Cursor** 的付费版本。使用几个月后，感觉非常流畅。

在我自己使用它的同时，我也经常向同事和朋友推荐 Cursor。然而，他们中的许多人仍然有一些疑问，例如：

*   它相比原生 ChatGPT 或 Claude 有什么优势？Cursor 的强大主要是因为 Claude Sonnet 3.5 吗？
*   它与 GitHub Copilot 有何不同？为什么价格是它的两倍？
*   Cursor 只适用于快速创建小型演示项目吗？
*   Codeium 最近发布了 [Windsurf](https://codeium.com/windsurf)，根据一些博主的视频，它看起来更流畅。我应该切换到它吗？
*   Coding Copilot 只对初学者有用吗？
*   在 AI Copilot 浪潮中，我们如何继续提升我们的编码技能？或者我们最终会被代理完全取代吗？

这些都是常见的问题。我发现解决这些问题的最佳方法是通过现场编码演示。在程序员节（10 月 24 日），我在公司内部做了一个演示，通过实际操作展示了 Cursor 的优势和使用方法。但是，由于我在演示中使用了公司内部代码，所以不适合直接分享。

在这篇文章中，我稍微调整了内容，以便与更广泛的读者分享 Cursor 和 AI 编码副驾驶的一些吸引力和实践见解。

Cursor 是一家由一群年轻的 MIT 学生于 2022 年创立的公司。当时，GitHub Copilot 已经在市场上占据了显著地位。当 Cursor 的产品最初发布时，我简单尝试了一下，发现它相当基础——它似乎只不过是将与 ChatGPT/Claude 聊天的过程直接集成到 VSCode 中以生成代码。没有什么特别突破性的。

然而，它随后的发展超出了几乎所有人的预期。让我们看看当时的市场格局：

*   对于专业开发者来说，GitHub Copilot 具有明显的优势。它几乎单枪匹马地验证了编码副驾驶的产品市场匹配度（PMF），并实现了 1 亿美元的年度经常性收入（ARR）。由于 GitHub 和 VSCode 都在微软的旗下，而当时的领先代码模型 OpenAI 的 GPT-3.5 和 Codex 与微软紧密合作，GitHub Copilot 拥有强大的优势。
*   对于非程序员来说，像 ChatGPT、Claude 或 Replit 这样的产品主导着最大的流量入口。对于一次性任务或演示项目，这些工具已经足够了。将这些功能迁移到 VSCode 中并没有明显的优势。

那么，为什么 Cursor 胆敢_**重塑**_微软的 IDE，并使用已经与微软紧密集成的 OpenAI 模型来与这些主要参与者竞争呢？

在我自己体验了 Cursor 并回顾了[其创始团队的采访](https://www.youtube.com/watch?v=oFfVt3S51T4)之后，Cursor 确定了几个清晰而独特的切入点：

*   Cursor 的重点很明确：专业开发者。他们并不打算与 ChatGPT、v0 或 Bolt 等工具竞争。事实上，Cursor 和这些工具背后的愿景可能从根本上不同（例如，关于程序员将来是否仍然存在的争论）。如果用户无法区分这些工具之间的差异，他们可能不是 Cursor 的目标受众。
*   他们的关键洞察：编码不仅仅是 “补全”，还有“编辑”。这意味着包括删除和补全。虽然现在这听起来很明显，但在当时，所有的编码副驾驶只提供简单的自动补全。即使在今天，Cursor 的“Tab” 体验仍然独树一帜，尽管 Windsurf 已经开始模仿它。
*   扩展编辑概念：Cursor 通过在聊天界面生成代码，然后应用它来创建跨整个文件甚至多个文件的编辑（使用 diff）。这种工作流程展示了他们对开发者需求的深刻理解。
*   快速迭代与大公司惯性：虽然像 GPT 这样的大型模型已经从 3 版发展到 3.5 版再到 4 版，但 GitHub Copilot 的用户体验并没有太大变化。大公司通常面临较慢的产品迭代周期，而 Cursor 团队意识到他们可以更快地行动，以探索和释放模型进步的全部潜力。

这些策略值得学习。通过明确的重点、对开发者工作流程的深刻理解以及快速的迭代，即使像 Cursor 这样的小团队也能够挑战像 GitHub Copilot 这样的巨头。

如前所述，Cursor 的目标是专业开发者。让我们进一步阐明它在哪些场景中能发挥最大价值，以及它与其他工具有何不同：

*   对新手和经验丰富的开发者都有益。无论你是初学者还是经验丰富的程序员，Cursor 都能显著提升你的工作流程。特别是经验丰富的开发者，不应因为对自身技能过于自信而忽视这种新范式的潜力。
*   针对维护现有项目进行了优化。大多数专业开发者的大部分时间都花在维护和迭代现有中大型项目上，而不是每天都从头开始创建新项目。许多专注于 “从头构建应用程序” 的在线教程未能代表典型的工作流程，也没有突出 Cursor 与 Claude Canvas 等工具之间的区别。
*   当前模型的局限性。今天的模型还无法仅凭少量指令就能完成大型项目中的整个功能。过度依赖基于聊天的开发可能会导致成功率降低。更好的方法是将 Cursor 视为 “结对编程副驾驶”，而不是 “实习程序员”。

让我们探讨 Cursor 的功能如何在日常任务中提高生产力：

Cursor Tab
----------

_Cursor_ Tab 目前是其最独特的特性。本质上，它会预测你接下来可能要编辑的代码片段，并自动为你完成。让我们来看几个场景：

### 场景一：将 print 更改为 logger

在一个阳光明媚的早晨，你正在与你的结对编程伙伴一起修改一些代码。你可能会告诉你的伙伴，在原型开发期间，这个文件中有很多 print 语句。现在项目准备投入生产了，我们应该将它们全部更改为 logger 输出。你还需要确保不同类型的信息以适当的日志级别进行记录。

你当然可以通过按`CMD + L`在 Cursor 中调用聊天窗口，输入整个请求，然后等待 Cursor 生成整个文件的 diff。但是，这个请求也可以通过编写代码来隐式表达。例如，你可以在文件中直接添加以下内容：

```
import logging

logger = logging.getLogger(__name__)

# existing code omitted...
```

然后，你只需要修改第一个 print 语句，你的编程伙伴 Cursor 就会理解你的意图。从那里开始，只需按 Tab 键，Tab 键，Tab 键，你就会惊讶地发现 Cursor“猜测” 了你想要修改的所有位置，并智能地设置了正确的日志级别。

注意这种方法与在聊天窗口中输入整个请求相比有多快。它可能更快，并且跳过了后续的应用 + 审查 + 接受步骤。因此，通常值得考虑一下，是否通过示例代码或简单的注释来表达一些意图会更快。

### 场景二：添加函数参数

这是另一个常见的场景。与其使用自然语言描述，“我想向函数添加一个参数，解释其用途，修改使用该参数的位置，并更新对该函数的所有调用”，你通常可以通过直接编辑函数来达到相同的效果。只需将参数写入函数中，Cursor 就能推断出你的意图。

例如，考虑 Cursor 官方网站上的一个用例：

![](https://www.pixelstech.net/article/images/cursor-example.png)

_示例：添加 dropout 参数_

你将 dropout 参数添加到类的`__init__`方法中。Cursor 将自动：

*   更新文件中所有需要使用该参数的位置。
*   修改代码库中对 LSTMModel 的所有其他调用，添加 dropout 的必要初始化。

此功能允许 Cursor Tab 处理 IDE 本身难以轻松管理的许多小型重构任务。

### 与 GitHub Copilot 的区别

如果你使用过其他补全工具，例如 GitHub Copilot，那么通过编辑代码来表达意图的方法可能会让你感觉熟悉。通常，当 Copilot 的建议不准确时，你可能会发现自己：

*   输入几个额外的字符来引导 Copilot 朝正确的方向前进。
*   删除一些代码以使 Copilot“忘记” 上下文并重新生成建议。
*   更改光标位置以促使 Copilot 从不同的点开始补全。

Cursor Tab 自动执行这些手动调整，例如 “删除一些代码” 或“移动光标”。因此，与 GitHub Copilot 等工具相比，Cursor 在入门和易用性方面感觉要 “智能” 得多。

这种简化的体验展示了 Cursor 对开发者工作流程的理解，以及它简化甚至细微任务的能力，从而提高了专业开发者的生产力。

内联聊天
----

在 Cursor 中使用`CMD + K`可以在光标位置或选定的代码上调出一个内联聊天窗口。与侧边栏聊天相比，内联聊天有两个主要优势：

*   上下文感知编辑。内联聊天根据光标位置或选定的代码固有地理解上下文，专门关注编辑任务。
*   并行处理。可以同时打开多个内联聊天窗口，使你能够同时处理多个编辑，而无需等待一个完成才能开始下一个。

我个人更喜欢将内联聊天用于以下任务：

*   模板式代码生成：例如，参考文件的其他部分来编写新的 API、数据库操作、数据模型等。这种低熵代码生成是 Cursor 处理得非常好的事情，节省了很多时间。
*   向选定的代码添加注释：选择一段代码后，我可以要求 Cursor 添加注释并检查是否有任何不清楚的部分。
*   重命名函数 / 变量：选择函数或变量名称后，我要求 Cursor 建议一个更好的名称。
*   在终端中编写复杂的命令行指令：我也可以调用 Cursor 来帮助我编写复杂的命令，例如 Docker、git 等。所以，也许我不再需要 Warp 了？

![](https://www.pixelstech.net/article/images/terminal-cmd.png)

_示例：在终端中生成命令_

聊天
--

标准的侧边栏聊天是最熟悉的格式，通常与 ChatGPT 或 Claude 等产品进行比较。但是，作为一个专业的 IDE，Cursor 在处理现有项目时展现出显著的优势，尤其是在理解上下文的能力方面。让我们探讨一些典型的场景：

### 场景一：重构 / 功能修改

想象一下，你与你的编程伙伴一起进行重构，其中模型层的更改需要对调用此模型的文件进行相应的修改，包括对复杂控制流逻辑的调整。如果使用 ChatGPT，工作流程可能如下所示：

1.  手动收集上下文，包括模型更改、当前文件和指令本身。
2.  将所有这些粘贴到 ChatGPT 中。
3.  等待 ChatGPT 生成新代码，将其复制回 IDE。
4.  使用 diff 工具检查缺失、不正确或过多的更改。
5.  如果出现问题，请通过将错误消息复制回 ChatGPT 来重复此过程。

这个过程繁琐且容易出错。在 Cursor 中，这些痛点得到了无缝解决：

*   使用 @轻松指定 Cursor 可以引用的文件、文件夹或代码定义。
*   生成代码后，单击一下即可应用。Cursor 直接更新当前文件，并提供 “拉取请求” 样式的 diff 进行审查。
*   如果发现问题，可以提出后续问题以进一步迭代。为了避免 “会话污染”，你可以启动一个新会话并重新引入必要的信息。
*   更改被接受后，可能会出现 lint 错误或测试失败。与其手动复制错误消息，你可以使用 **AI Fix in Chat**（用于 lint 错误）或 **Debug with AI**（在终端中）直接解决它们。

![](https://www.pixelstech.net/article/images/cursor-debug.png)

_示例：自动修复错误_

在下面的示例中，在终端中运行`mypy`进行代码检查会显示两个错误。只需单击 **Debug with AI** 按钮，错误就会自动发送到 Cursor Chat。Cursor 会生成一个代码 diff，应用修复后，一切正常工作。这大大提高了效率。

### 场景二：单元测试生成

无论你遵循 TDD 方法，还是先编写功能然后再添加测试，你都可以与 Cursor 协作来快速构建测试模板（包括依赖项、模拟等），并进行迭代以涵盖更多场景。

![](https://www.pixelstech.net/article/images/cursor-test.png)

_示例：生成单元测试_

生成单元测试后，直接运行它们。如果出现错误，可以将其与 Debug with AI 功能结合使用以快速修复问题。

### 场景三：性能优化

这是官方网站上的一个示例，其中一些 Rust 代码正在被优化。在日常工作中，你可以使用聊天让 Cursor 快速查看整个文件，并请求在性能、稳定性和安全性等方面的检查和优化。

![](https://www.pixelstech.net/article/images/cursor-optimization.png)

### 场景四：集成网络搜索

在调试问题或学习新框架时，像 [**devv**](https://devv.ai/)、[**phind**](https://www.phind.com/) 或 [**Perplexity**](https://www.perplexity.ai/) 这样的工具经常在编码领域使用。类似地，你可以在 Cursor 中使用`@Web`命令执行网络搜索，检索全面且最新的知识，并将其与你的代码库结合起来，以提供更有针对性的解决方案。例如，你可以让 Cursor 帮助你将项目从 Poetry 迁移到 UV：

![](https://www.pixelstech.net/article/images/cursor-web.png)

_网络搜索集成_

这展示了如何使用 Cursor 处理传统情况下需要频繁进行网络搜索的场景，包括环境配置、依赖项安装和复杂问题的故障排除。

此外，还有一个类似的功能叫做`@Docs`，对于正在经历不兼容的大版本更改的流行库特别有用。例如，Pydantic 1.x 已经广泛使用很长时间了，语言模型可能对其非常熟悉。但是，如果你的项目使用的是 Pydantic 2.x，那么将更新文档的 URL 导入 Cursor 对于显著提高生成的代码的准确性至关重要。

![](https://www.pixelstech.net/article/images/cursor-python.png)

_内置和导入文档支持_

### 场景五：代码审查

在早期版本中，这是一个独立的选项卡，但在新版本中，它似乎已升级为 **Bug Finder**，现在根据使用情况收费。但是，你仍然可以在聊天中使用`@Git`命令让 Cursor 帮助你审查代码并识别潜在的错误。为了获得更好的结果，你可能需要改进你的提示。

![](https://www.pixelstech.net/article/images/code-review.png)

_AI 代码审查_

其他上下文生成
-------

在聊天中，`@`运算符允许对当前聊天上下文进行非常灵活的控制，这与与真正的程序员交流非常相似。除了前面提到的功能外，你还可以：

*   @Recommended：自动推荐相关的上下文。
*   @Codebase：导入整个代码库，这对于理解项目的代码或查找功能的特定实现非常有用。
*   @Notepad：此功能不太常用，但对于创建开发计划或功能规范可能会有所帮助，这些规范可以在以后的特定代码文件中引用。
*   @Lint errors：自动修复 LSP（语言服务器协议）检测到的代码问题。

这种以如此灵活的方式控制上下文的能力反映了 Cursor 团队对程序员日常工作流程的深刻理解，并使其有别于通用的聊天机器人。

此外，还可以将设计图上传到聊天中供 Cursor 处理。但是，由于大型模型处理图像的能力仍然有限，因此此功能目前还不够实用。

许多博主都推荐了这个功能，我理解它主要将聊天中的单文件编辑扩展到多文件编辑和创建。事实上，在 0.43 版本之前，我很少使用此功能，因为当前模型的能力使得在复杂项目中准确生成跨多个文件的编辑具有挑战性（如果你不同意，请随意提供示例）。

因此，简单地说，复杂度越来越高的任务通常可以映射到 tab -> 内联聊天 -> 聊天 -> composer，形成一个逐渐递进的过程。

有趣的是，随着 Windurf 的发布，人们意识到作曲家代理的工作流程可能过于简单，导致结果不尽如人意。Windurf 的 Cascade，虽然需要更多时间 “思考”，但通常使用相同的模型可以取得更好的结果。因此，Cursor 在 0.43 版本中快速引入了作曲家代理模式。

![](https://www.pixelstech.net/article/images/composer.png)

_使用作曲家阅读开源代码_

现在，Cursor 集成了多步骤上下文检索、阅读、执行命令（终端）、收集反馈和确定下一步操作，类似于 ReAct 代理工作流程。正如我们已经看到的，Cursor 在各个阶段都嵌入了 AI 能力，通过代理连接这些能力是一种自然的演进。

早期的演示也使用了作曲家在非代码领域，例如将个人知识存储在本地 markdown 文件中（如 Obsidian）并使用作曲家进行 “AI 驱动的搜索和问答”。但是，在新版本中，作曲家似乎更关注编码场景，因为我在多次尝试后无法触发文档检索。另一方面，聊天中的`@Codebase`功能可以实现此效果。

其他技巧
----

还值得一提的是`cursorrules`文件，它可以被认为是当前项目的通用知识文档。它可能包括：

*   项目技术栈的指南，例如特定的框架版本。
*   项目特定的编码规范，例如命名、注释、错误处理、日志记录标准以及性能 / 安全注意事项。

你可以在 cursor.directory 中找到一些项目模板，修改它们，并将其用于你自己的项目。

从以上介绍可以看出，Cursor 已经在我们的日常工作中帮助我们完成了许多**低熵**任务，例如：

*   编写各种编程语言和框架中的习惯模式；即使对于你不熟悉的框架，Cursor 也可以帮助你快速入门。
*   项目存储库中的常用编码风格和表达式；你的项目结构越清晰，代码的可读性越高，这方面就会越突出。
*   运行代码、处理错误、搜索和尝试修复等任务——Cursor 可以帮助提高这些重复性任务的效率。

从**流程理论**的角度来看，一方面，Cursor 通过自动完成和聊天帮助我们完成低难度 “无聊” 的打字任务。另一方面，大型模型的丰富知识结合对代码库的深入上下文理解（通过 RAG）有助于提高程序员的知识库，减少由不熟悉的技术或代码引起的挑战和焦虑。使用 Cursor 感觉就像与虚拟编程伙伴配对，让我们能够保持专注和创造力。

为了更好地利用这些工具提高 AI 时代的生产力，我们的重点将更多地转向**设计**和**验证**阶段。

*   作为虚拟编程伙伴，Cursor 像人类一样，需要理解我们编写的代码才能提供更好的建议。因此，在 AI 时代，编写清晰易读的代码的重要性越来越高。
*   组织良好的代码将使在使用 @命令时更容易找到正确的上下文，并且随着你更深入地使用 Cursor，这一点会变得更加明显。良好的命名和单一职责等原则非常有用。
*   AI 和人类程序员在认知模式上存在显著差异。如果你参与了与 LLM 相关的应用程序，你可能会更清楚地了解 AI 如何解释代码。例如，在注释中编写更多案例和思考过程，避免复杂的 “多跳检索” 逻辑，并偶尔询问 AI 如何理解一段代码或要求它使用你的代码执行任务，可以优化其推理（类似于提示优化技术）。
*   随着 AI 生成的代码能力越来越强大和快速，有效地审查和验证这些输出很快就会成为瓶颈。一方面，自动化测试将变得越来越重要。另一方面，像 Cursor 这样的产品可能会开始提供代码审查方面的帮助。

当然，这些只是我初步的想法，欢迎大家分享想法并参与讨论。

以下是其他一些 AI 辅助编程产品的简要比较：

*   OpenAI Canvas，Claude Artifacts：这些产品面向更广泛的受众，主要针对 “一次性” 代码生成或 MVP 开发。与 Cursor 不同，它们不提供与现有代码库上下文深度集成或适应复杂的 IDE 工作流程。
*   GitHub Copilot，Codeium，Supermaven：这些 IDE 插件产品在完成体验方面仍然存在显著差距。Cursor Tab 似乎是一个专门的模型，尽管技术障碍可能不高，但尚不清楚为什么 GitHub Copilot 没有效仿。在聊天功能方面，GitHub Copilot 缺乏 Cursor 中看到的灵活的上下文控制。
*   “代理” 产品（例如，devin，replit，bolt，v0）：如果产品过于通用，目前很难取得良好的效果。专注于特定领域的产品，例如前端代码生成，可能会略微表现更好，但大多限于小型演示级别的生成。这与对 AI 在编程未来更广泛的推测有关——程序员的工作最终会消失吗？
*   Windsurf：Windsurf 最大的问题是其自动完成功能仍然非常有限，而且由于它比较新，许多功能（例如 Python LSP）及其稳定性不如 Cursor。但是，它更经济实惠，值得关注。
*   Cursor 的开源替代品（例如，aider，cline）：这些替代品允许 “按需付费” 模式，但通常缺乏 Cursor 提供的抛光和改进水平。
*   JetBrains AI：与 VSCode 相比，JetBrains 在 Java 生态系统中仍然拥有许多忠实用户，这阻止了许多人转向 Cursor。但是，JetBrains AI 的市场反馈似乎很差，甚至 JetBrains 中的 GitHub Copilot 插件也比其他环境中的效果差。

截至 2024 年 12 月，如果你不想进行实验，Cursor 是一个不错的选择。从 JetBrains 迁移应该不会太困难：

*   搜索并安装特定语言的推荐插件；VSCode 在前端、Python、Rust 和 Go 支持方面表现良好。
*   最好重新学习键盘快捷键，你也可以安装 IntelliJ IDEA Keybindings 插件。
*   全局搜索双 Shift 不再可用，请改用 CMD + P、CMD + T、SHIFT + CMD + F。
*   图形化 Git 操作略显薄弱，但对于基本使用仍然足够。
*   高可配置性提供了极大的灵活性，尽管有一些小的怪癖需要解决。

有关迁移的更详细指南，你可以查看针对此转换的在线资源。

从 Cursor 的角度来看，未来的改进可以从两个关键角度考虑：代理框架和程序员工作流程。虽然这篇文章已经很长了，但一些值得总结的要点包括：

*   语音集成：如果我们将 Cursor 视为虚拟编程伙伴，集成实时语音输入可能会非常有趣。这可以允许在代码生成时描述代码，使体验更加自然和无缝。
*   高效的代码审查：一个重要的改进方向是如何有效地审查 AI 生成的代码。当前的代码审查产品还有很大的改进空间，尤其是在审查内容的组织方式上，这通常感觉僵硬且缺乏灵活性。
*   架构设计辅助：Cursor 能否在架构设计层面提供帮助？第一步可能是允许 Cursor 以更 “分层” 的方式理解代码，而不仅仅是提供扁平的上下文。

程序员职业的未来：一个值得探讨的问题是，随着 AI 能力的增强，程序员的角色是否会发生变化。

*   Cursor 显然旨在成为专业程序员的 “高端工具”，相信编程职业将在长期内继续存在，不会被 AI 完全取代。使用 Cursor 的障碍相对较高，因为它更适合程序员当前的工作方式。
*   相反，像 Devin、Magic.dev 等产品似乎更倾向于成为更通用的 “通用编码代理”，这可能会取代程序员。未来可能是“每个人都可以开发自己的应用程序”，或者“只需要产品经理” 吗？

当我第一次尝试 MidJourney 和 Suno 时，我想知道未来是否每个人都会成为数字艺术家。但很快，我意识到我没有从事这类工作的 “创造冲动”。即使看到很多其他人的作品，我也常常无法表达自己想创作什么。最后，我发现我对 AI 生成艺术的需求仅限于在撰写文章时创建封面图片，而这一功能未来可能会集成到许多内容创建者的平台中。

同样，我对程序员未来的想法也类似：代码创作可能比艺术、写作、音乐或视频更专业化的技能，可能较少人会考虑开发自己的应用程序。但是，为个性化垂直应用程序生成代码可能会成为其他特定领域产品中包含的功能。

_**注意：本文经原作者 RandomGenerator 授权翻译并在我们的网站上发布。原文为中文，位于 [https://mp.weixin.qq.com/s/JVb7-4a2XOFhfeJusaxvFg](https://mp.weixin.qq.com/s/JVb7-4a2XOFhfeJusaxvFg)**_