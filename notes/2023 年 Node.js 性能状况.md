> æœ¬æ–‡ç”± [ç®€æ‚¦ SimpRead](http://ksria.com/simpread/) è½¬ç ï¼Œ åŽŸæ–‡åœ°å€ [blog.rafaelgss.dev](https://blog.rafaelgss.dev/state-of-nodejs-performance-2023)

> ä¸“æ³¨äºŽåº”ç”¨ç¨‹åºæ€§èƒ½å’Œè½¯ä»¶æž¶æž„çš„æŠ€æœ¯åšå®¢ã€‚å‰ç«¯åªæ˜¯ JSON ......

ä»Šå¹´æ˜¯ 2023 å¹´ï¼Œ[æˆ‘ä»¬å‘å¸ƒäº† Node.js v20](https://nodejs.org/en/blog/release/v20.0.0)ã€‚è¿™æ˜¯ä¸€é¡¹é‡å¤§æˆå°±ï¼Œæœ¬æ–‡æ—¨åœ¨ä½¿ç”¨ç§‘å­¦æ•°å­—æ¥è¯„ä¼° Node.js çš„æ€§èƒ½çŠ¶æ€ã€‚

æ‰€æœ‰åŸºå‡†æµ‹è¯•ç»“æžœéƒ½åŒ…å«å¯é‡çŽ°çš„ç¤ºä¾‹å’Œç¡¬ä»¶è¯¦ç»†ä¿¡æ¯ã€‚ä¸ºäº†å‡å°‘æ™®é€šè¯»è€…çš„å™ªéŸ³ï¼Œå¯é‡çŽ°çš„æ­¥éª¤å°†æŠ˜å åœ¨æ‰€æœ‰éƒ¨åˆ†çš„å¼€å¤´ã€‚

æœ¬æ–‡æ—¨åœ¨å¯¹ä¸åŒç‰ˆæœ¬çš„ Node.js è¿›è¡Œå¯¹æ¯”åˆ†æžã€‚å®ƒçªå‡ºäº†æ”¹è¿›å’ŒæŒ«æŠ˜ï¼Œå¹¶æä¾›äº†å¯¹è¿™äº›å˜åŒ–èƒŒåŽåŽŸå› çš„è§è§£ï¼Œä½†æ²¡æœ‰ä¸Žå…¶ä»– JavaScript è¿è¡Œæ—¶è¿›è¡Œä»»ä½•æ¯”è¾ƒã€‚

ä¸ºäº†è¿›è¡Œè¿™ä¸ªå®žéªŒï¼Œæˆ‘ä»¬ä½¿ç”¨äº† Node.js ç‰ˆæœ¬**16.20.0**ã€**18.16.0**å’Œ**20.0.0**ï¼Œå¹¶å°†åŸºå‡†å¥—ä»¶åˆ†ä¸ºä¸‰ä¸ªä¸åŒçš„ç»„ï¼š

1.  Node.js å†…éƒ¨åŸºå‡†

é‰´äºŽ Node.js åŸºå‡†æµ‹è¯•å¥—ä»¶çš„å·¨å¤§è§„æ¨¡å’Œè€—æ—¶ç‰¹æ€§ï¼Œæˆ‘æœ‰é€‰æ‹©åœ°é€‰æ‹©äº†åœ¨æˆ‘çœ‹æ¥å¯¹ Node.js å¼€å‘äººå‘˜å’Œé…ç½®å½±å“æ›´å¤§çš„åŸºå‡†æµ‹è¯•ï¼Œä¾‹å¦‚ä½¿ç”¨ .è¯»å– 16 MB çš„æ–‡ä»¶`fs.readfile`ã€‚è¿™äº›åŸºå‡†æµ‹è¯•æŒ‰æ¨¡å—åˆ†ç»„ï¼Œä¾‹å¦‚`fs`å’Œ`streams`ã€‚æœ‰å…³ Node.js åŸºå‡†æµ‹è¯•å¥—ä»¶çš„æ›´å¤šè¯¦ç»†ä¿¡æ¯ï¼Œè¯·å‚é˜… [Node.js æºä»£ç ](https://github.com/nodejs/node/tree/main/benchmark)ã€‚

2.  [nodejs-bench-æ“ä½œ](https://github.com/RafaelGSS/nodejs-bench-operations/)

æˆ‘ç»´æŠ¤ä¸€ä¸ªåä¸ºçš„å­˜å‚¨åº“[`nodejs-bench-operations`](https://github.com/RafaelGSS/nodejs-bench-operations)ï¼Œå…¶ä¸­åŒ…æ‹¬æ‰€æœ‰ Node.js ä¸»è¦ç‰ˆæœ¬çš„åŸºå‡†æ“ä½œï¼Œä»¥åŠæ¯ä¸ªç‰ˆæœ¬ç³»åˆ—çš„æœ€åŽä¸‰ä¸ªç‰ˆæœ¬ã€‚è¿™æ ·å¯ä»¥è½»æ¾æ¯”è¾ƒä¸åŒç‰ˆæœ¬ä¹‹é—´çš„ç»“æžœï¼Œä¾‹å¦‚ Node.js v16.20.0 å’Œ v18.16.0ï¼Œæˆ– v19.8.0 å’Œ v19.9.0ï¼Œç›®çš„æ˜¯è¯†åˆ« Node.js ä»£ç åº“ä¸­çš„å›žå½’ã€‚å¦‚æžœæ‚¨å¯¹ Node.js æ¯”è¾ƒæ„Ÿå…´è¶£ï¼Œå…³æ³¨æ­¤å­˜å‚¨åº“å¯èƒ½ä¼šæœ‰æ‰€å¸®åŠ©ï¼ˆå¦‚æžœæ‚¨è§‰å¾—æœ‰å¸®åŠ©ï¼Œè¯·ä¸è¦å¿˜è®°ç»™å®ƒä¸€ä¸ªæ˜Ÿï¼‰ã€‚

3.  HTTP æœåŠ¡å™¨ï¼ˆæ¡†æž¶ï¼‰

è¿™ä¸ªå®žç”¨çš„ HTTP åŸºå‡†æµ‹è¯•å‘å„ç§è·¯ç”±å‘é€å¤§é‡è¯·æ±‚ï¼Œè¿”å›ž JSONã€çº¯æ–‡æœ¬å’Œé”™è¯¯ï¼Œä»¥`express`å’Œ`fastify`ä½œä¸ºå‚è€ƒã€‚[ä¸»è¦ç›®çš„æ˜¯ç¡®å®šä»Ž Node.js å†…éƒ¨åŸºå‡†æµ‹è¯•å’Œnodejs-bench-operations](https://github.com/RafaelGSS/nodejs-bench-operations)èŽ·å¾—çš„ç»“æžœæ˜¯å¦é€‚ç”¨äºŽå¸¸è§çš„ HTTP åº”ç”¨ç¨‹åºã€‚

> ðŸ’¡ æ›´æ–°ï¼šç”±äºŽæœ¬æ–‡æ¶µç›–çš„å†…å®¹å¹¿æ³›ï¼Œç¬¬ä¸‰æ­¥ä¹Ÿæ˜¯æœ€åŽä¸€æ­¥å°†åœ¨åŽç»­æ–‡ç« ä¸­åˆ†äº«ã€‚[è¦ä¿æŒæ›´æ–°å’ŒæŽ¥æ”¶é€šçŸ¥ï¼Œæˆ‘é¼“åŠ±æ‚¨åœ¨Twitter](https://twitter.com/_rafaelgss) / [LinkedIn](https://www.linkedin.com/in/rafaelgss/)ä¸Šå…³æ³¨æˆ‘ ã€‚

çŽ¯å¢ƒ
--

ä¸ºæ‰§è¡Œæ­¤åŸºå‡†æµ‹è¯•ï¼Œ[AWS ä¸“ç”¨ä¸»æœº](https://aws.amazon.com/ec2/dedicated-hosts/)ä¸Žä»¥ä¸‹è®¡ç®—ä¼˜åŒ–å®žä¾‹ä¸€èµ·ä½¿ç”¨ï¼š

*   c6i.xlarge (Ice Lake) 3.5 GHz - è®¡ç®—ä¼˜åŒ–
*   4 ä¸ª vCPU
*   8 GB å†…å­˜
*   Canonicalã€Ubuntuã€22.04 LTSã€amd64 æžœé…±
*   1GiB SSD å·ç±»åž‹

Node.js å†…éƒ¨åŸºå‡†
------------

åœ¨æ­¤åŸºå‡†æµ‹è¯•ä¸­é€‰æ‹©äº†ä»¥ä¸‹æ¨¡å—/å‘½åç©ºé—´ï¼š

*   `fs`- Node.js æ–‡ä»¶ç³»ç»Ÿ
*   `events`- Node.js äº‹ä»¶ç±»`EventEmitter`/`EventTarget`
*   `http`- Node.js HTTP æœåŠ¡å™¨ + è§£æžå™¨
*   `misc`- Node.js å¯åŠ¨æ—¶é—´ä½¿ç”¨`child_processes`å’Œ`worker_threads`+`trace_events`
*   `module`- èŠ‚ç‚¹.js`module.require`
*   `streams`- Node.js æµåˆ›å»ºã€é”€æ¯ã€å¯è¯»ç­‰
*   `url`- Node.js URL è§£æžå™¨
*   `buffers`- Node.js ç¼“å†²åŒºæ“ä½œ
*   `util`- Node.js æ–‡æœ¬ç¼–ç å™¨/è§£ç å™¨

ä½¿ç”¨çš„é…ç½®å¯åœ¨ [RafaelGSS/node#state-of-nodejs](https://github.com/RafaelGSS/node/tree/state-of-nodejs)èŽ·å¾—ï¼Œæ‰€æœ‰ç»“æžœéƒ½å‘å¸ƒåœ¨ä¸»å­˜å‚¨åº“ä¸­ï¼š [State of Node.js Performance 2023](https://github.com/RafaelGSS/state-of-nodejs-performance-2023)ã€‚

### Node.js åŸºå‡†æµ‹è¯•æ–¹æ³•

åœ¨å±•ç¤ºç»“æžœä¹‹å‰ï¼Œè§£é‡Šç”¨äºŽç¡®å®šåŸºå‡†ç»“æžœç½®ä¿¡åº¦çš„ç»Ÿè®¡æ–¹æ³•è‡³å…³é‡è¦ã€‚è¿™ä¸ªæ–¹æ³•åœ¨ä¹‹å‰çš„ä¸€ç¯‡åšæ–‡ä¸­æœ‰è¯¦ç»†çš„è§£é‡Šï¼Œä½ å¯ä»¥å‚è€ƒè¿™é‡Œï¼š **[å‡†å¤‡å’Œè¯„ä¼°åŸºå‡†](https://blog.rafaelgss.dev/preparing-and-evaluating-benchmarks)**ã€‚

ä¸ºäº†æ¯”è¾ƒæ–° Node.js ç‰ˆæœ¬çš„å½±å“ï¼Œæˆ‘ä»¬åœ¨æ¯ä¸ªé…ç½®å’Œ Node.js 16ã€18 å’Œ 20 ä¸Šå¤šæ¬¡è¿è¡Œæ¯ä¸ªåŸºå‡†æµ‹è¯• (30)ã€‚å½“è¾“å‡ºæ˜¾ç¤ºä¸ºè¡¨æ ¼æ—¶ï¼Œæœ‰ä¸¤åˆ—éœ€è¦ç‰¹åˆ«æ³¨æ„ï¼š

1.  _æ”¹è¿›_-ç›¸å¯¹äºŽæ–°ç‰ˆæœ¬çš„æ”¹è¿› **ç™¾åˆ†æ¯”**
2.  _ä¿¡å¿ƒ_- å‘Šè¯‰æˆ‘ä»¬æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç»Ÿè®¡è¯æ®æ¥éªŒè¯_æ”¹è¿›_

ä¾‹å¦‚ï¼Œè€ƒè™‘ä¸‹è¡¨ç»“æžœï¼š

æœ‰ 0.1% çš„é£Žé™©`fs.readfile`æ²¡æœ‰ä»Ž Node.js 16 æå‡åˆ° Node.js 18ï¼ˆç½®ä¿¡åº¦ ***ï¼‰ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯¹ç»“æžœéžå¸¸æœ‰ä¿¡å¿ƒã€‚è¡¨ç»“æž„å¯ä»¥ç†è§£ä¸ºï¼š

*   `fs/readfile.js`- åŸºå‡†æ–‡ä»¶
*   `concurrent=1 len=16777216 encoding='ascii' duration=5`- åŸºå‡†é€‰é¡¹ã€‚æ¯ä¸ªåŸºå‡†æ–‡ä»¶å¯ä»¥æœ‰å¾ˆå¤šé€‰é¡¹ï¼Œåœ¨æœ¬ä¾‹ä¸­ï¼Œå®ƒä½¿ç”¨ **ASCII**ä½œä¸ºç¼–ç æ–¹æ³• åœ¨**5ç§’å†…è¯»å–****1 ä¸ª****16777216**å­—èŠ‚çš„å¹¶å‘æ–‡ä»¶ã€‚

> _å¯¹äºŽç»Ÿè®¡å¤´è„‘ï¼Œè„šæœ¬æ‰§è¡Œ[ç‹¬ç«‹/æœªé…å¯¹çš„ 2 ç»„ t æ£€éªŒ](https://en.wikipedia.org/wiki/Student%27s_t-test#Equal_or_unequal_sample_sizes%2C_unequal_variances_%28sX1_%3E_2sX2_or_sX2_%3E_2sX1%29)ï¼Œé›¶å‡è®¾ä¸¤ä¸ªç‰ˆæœ¬çš„æ€§èƒ½ç›¸åŒã€‚å¦‚æžœ p å€¼å°äºŽ ï¼Œåˆ™ç½®ä¿¡åº¦å­—æ®µå°†æ˜¾ç¤ºæ˜Ÿå·`0.05`ã€‚â€” [ç¼–å†™å’Œè¿è¡ŒåŸºå‡†](https://github.com/nodejs/node/blob/main/doc/contributing/writing-and-running-benchmarks.md#comparing-nodejs-versions)_

### åŸºå‡†è®¾ç½®

1.  å…‹éš† fork Node.js ä»“åº“
2.  ç»“å¸`state-of-nodejs`åˆ†è¡Œ
3.  åˆ›å»º Node.js 16ã€18 å’Œ 20 äºŒè¿›åˆ¶æ–‡ä»¶
4.  è¿è¡Œ [`benchmark.sh`](https://github.com/RafaelGSS/state-of-nodejs-performance-2023/blob/main/nodejs-internal-benchmark/benchmark.sh) è„šæœ¬

### æ–‡ä»¶ç³»ç»Ÿ

`fs.readfile`å°† Node.js ä»Ž 16 å‡çº§åˆ° 18 æ—¶ï¼Œä½¿ç”¨å¸¦æœ‰ç¼–ç çš„ API æ—¶è§‚å¯Ÿåˆ° 67% çš„æ”¹è¿›ï¼Œ`ascii` ä½¿ç”¨`utf-8`.

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174137/blog/state-of-nodejs-performance-2023/Untitled_jc1wyf.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174137/blog/state-of-nodejs-performance-2023/Untitled_jc1wyf.png)

åŸºå‡†æµ‹è¯•ç»“æžœè¡¨æ˜Žï¼Œå°† Node.js ä»Žç‰ˆæœ¬ 16 å‡çº§åˆ° 18 æ—¶ï¼Œä½¿ç”¨ç¼–ç çš„ APIæé«˜ äº†å¤§çº¦**67%** ï¼Œä½¿ç”¨æ—¶æé«˜äº† å¤§çº¦**12% ã€‚ç”¨äºŽåŸºå‡†æµ‹è¯•çš„æ–‡ä»¶æ˜¯ä½¿ç”¨ä»¥ä¸‹ä»£ç ç‰‡æ®µåˆ›å»ºçš„ï¼š**`fs.readfile``ascii``utf-8`

ä½†æ˜¯ï¼Œåœ¨ Node.js 20 of **27%**`fs.readfile`ä¸Šä½¿ç”¨with æ—¶å‡ºçŽ°äº†å›žå½’ã€‚æ­¤å›žå½’å·²æŠ¥å‘Šç»™ Node.js æ€§èƒ½å›¢é˜Ÿï¼Œé¢„è®¡ä¼šå¾—åˆ°ä¿®å¤ã€‚å¦ä¸€æ–¹é¢ï¼Œã€ å’Œæ˜¾ç¤ºäº†ä»Ž Node.js 18 åˆ° Node.js 20 çš„æ”¹è¿›ã€‚Node.js 18 å’Œ 20 ä¹‹é—´çš„æ¯”è¾ƒå¯ä»¥åœ¨ä¸‹é¢çš„åŸºå‡†æµ‹è¯•ç»“æžœä¸­çœ‹åˆ°ï¼š`ascii``fs.opendir``fs.realpath``fs.readdir`

å¦‚æžœæ‚¨ä½¿ç”¨çš„æ˜¯ Node.js 16ï¼Œåˆ™å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ Node.js 16 å’Œ Node.js 20 ä¹‹é—´çš„æ¯”è¾ƒ

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174215/blog/state-of-nodejs-performance-2023/Untitled_l9yunq.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174215/blog/state-of-nodejs-performance-2023/Untitled_l9yunq.png)

### äº‹ä»¶

è¯¥`EventTarget`ç­çº§åœ¨æ´»åŠ¨æ–¹é¢è¡¨çŽ°å‡ºæœ€æ˜¾ç€çš„è¿›æ­¥ã€‚è¯¥åŸºå‡†æ¶‰åŠä½¿ç”¨`EventTarget.prototype.dispatchEvent(new Event('foo'))`.

Upgrading from Node.js 16 to Node.js 18 can deliver an improvement of nearly **15%** in event dispatching performance. But the real jump comes when upgrading from Node.js 18 to Node.js 20, which can yield a performance improvement of up to **200%** when there is only a single listener.

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174293/blog/state-of-nodejs-performance-2023/Untitled_dnvmk0.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174293/blog/state-of-nodejs-performance-2023/Untitled_dnvmk0.png)

The `EventTarget` class is a crucial component of the Web API and is utilized in various parent features such as `AbortSignal` and `worker_threads`. As a result, optimizations made to this class can potentially impact the performance of these features, including `fetch` and `AbortController`. Additionally, the `EventEmitter.prototype.emit` API also saw a notable improvement of approximately **11.5%** when comparing Node.js 16 to Node.js 20. A comprehensive comparison is provided below for your reference:

### HTTP

The HTTP Servers are one of the most impactful layers of improvement in Node.js. It isnâ€™t a myth that most Node.js applications nowadays run an HTTP Server. So, any change can be easily considered a _semver-major_ and increase the efforts for a compatible improvement in performance.

Therefore, the HTTP server utilized is an `http.Server` that replies 4 chunks of 256 bytes each containing â€˜Câ€™ on each request, as you can see in this example:

When comparing the performance of Node.js 16 and Node.js 18, there is a noticeable 8% improvement. However, upgrading from Node.js 18 to Node.js 20 resulted in a significant improvement of **96.13%**.

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174353/blog/state-of-nodejs-performance-2023/Untitled_rjsskx.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174353/blog/state-of-nodejs-performance-2023/Untitled_rjsskx.png)

These benchmark results were collected using [`test-double-http`](https://github.com/nodejs/node/blob/main/benchmark/_test-double-benchmarker.js) benchmarker method. Which is, a simple Node.js script to send HTTP GET requests:

By switching to more reliable benchmarking tools such as `autocannon` or `wrk`, we observed a significant drop in the reported improvement â€” from **96%** to **9%**. [This indicates that the previous benchmarking method had limitations or errors](https://github.com/nodejs/performance/issues/80). However, the actual performance of the HTTP server has improved, and we need to carefully evaluate the percentage of improvement with the new benchmarking approach to accurately assess the progress made.

**Should I expect a 96%/9% performance improvement in my Express/Fastify application?**

Absolutely, not. Frameworks may opt not to use the internal HTTP API â€” thatâ€™s one of the reasons Fastify isâ€¦ fast! For this reason, another benchmark suite was considered in this report (3. HTTP Servers).

### Misc

According to our tests, the `startup.js` script has demonstrated a significant improvement in the Node.js process lifecycle, with a 27% boost observed from Node.js version 18 to version 20. This improvement is even more impressive when compared to Node.js version 16, where the startup time was reduced by 34.75%!

As modern applications increasingly rely on serverless systems, reducing startup time has become a crucial factor in improving overall performance. Itâ€™s worth noting that the Node.js team is always working towards optimizing this aspect of the platform, as evidenced by our strategic initiative: [https://github.com/nodejs/node/issues/35711](https://github.com/nodejs/node/issues/35711).

These improvements in startup time not only benefit serverless applications but also enhance the performance of other Node.js applications that rely on quick boot-up times. Overall, these updates demonstrate the Node.js teamâ€™s commitment to enhancing the platformâ€™s speed and efficiency for all users.

This benchmark is pretty straightforward. We measure the time elapsed when creating a new [mode] using the given [script] where [mode] can be:

*   `process` - a new Node.js process
*   `worker` - a Node.js worker_thread

And [script] is divided into:

*   `benchmark/fixtures/require-builtins` - a script that requires all the Node.js modules
*   `test/fixtures/semicolon` - an empty script â€” containing a single `;` (semicolon)

This experiment can be easily reproducible with [`hyperfine`](https://github.com/sharkdp/hyperfine) or `time`:

> ðŸ’¡ The warmup is necessary to consider the influence of the file system cache

The `trace_events` module has also undergone a notable performance boost, with a **7%** improvement observed when comparing Node.js version 16 to version 20. Itâ€™s worth noting that this improvement was slightly lower, at **2.39%**, when comparing Node.js version 18 to version 20.

### Module

`require()` (or `module.require`) has long been a culprit of slow Node.js startup times. However, recent performance improvements suggest that this function has been optimized as well. Between Node.js versions 18 and 20, we observed improvements of **4.20%** when requiring `.js` files, **6.58%** for `.json` files, and **9.50%** when reading directories - all of which contribute to faster startup times.

Optimizing `require()` is crucial because it is a function thatâ€™s used heavily in Node.js applications. By reducing the time it takes for this function to execute, we can significantly speed up the entire startup process and improve the user experience.

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174504/blog/state-of-nodejs-performance-2023/compare-module-18-20_nzhhvy.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174504/blog/state-of-nodejs-performance-2023/compare-module-18-20_nzhhvy.png)

### Streams

Streams are an incredibly powerful and widely used feature of Node.js. However, between Node.js versions 16 and 18, some operations related to streams became slower. This includes creating and destroying `Duplex`, `Readable`, `Transform`, and `Writable` streams, as well as the `.pipe()` method for Readable â†’ Writable streams.

The graph below illustrates this regression:

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174544/blog/state-of-nodejs-performance-2023/compare-streams-16-18-streams-bar_zfseff.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174544/blog/state-of-nodejs-performance-2023/compare-streams-16-18-streams-bar_zfseff.png)

However, this `pipe` regression was reduced in Node.js 20:

And as you may have noticed, some types of streams (`Transform` specifically) are regressed in Node.js 20. Therefore, Node.js 16 still has the fastest streams â€” for this specific benchmark, please do not read this benchmark result as â€˜Node.js streams in v18 and v20 are so slow!â€™ This is a specific benchmark that may or may not affect your workload. For instance, if you look at a naive comparison [in the nodejs-bench-operations](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v20.md#streamwritable), you will see that the following snippet performs better on Node.js 20 than its predecessors:

The fact is, the instantiation and destroy methods play an important role in the Node.js ecosystem. Hence, itâ€™s very likely to have a negative impact on some libraries. However, this regression is [being monitored closely](https://github.com/nodejs/performance/issues/79) in the [Node.js Performance WG](https://github.com/nodejs/performance).

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174569/blog/state-of-nodejs-performance-2023/compare-streams-16-20-streams-bar_xodyxx.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174569/blog/state-of-nodejs-performance-2023/compare-streams-16-20-streams-bar_xodyxx.png)

Note that the readable async iterator becomes slightly faster (~6.14%) on Node.js 20.

### URL

Since Node.js 18, a new URL parser dependency was added to Node.js â€” [Ada](https://github.com/ada-url/ada). This addition bumped the Node.js performance when parsing URLs to a new level. Some results could reach up to an improvement of **400%**. As a regular user, you may not use it directly. But if you use an HTTP server then itâ€™s very likely to be affected by this performance improvement.

The URL benchmark suite is pretty large. For this reason, only WHATWG URL benchmark results will be covered.

`url.parse()` and `url.resolve()` are both deprecated and legacy APIs. Even though its usage is considered a risk for any Node.js application, developers still use it. Quoting Node.js documentation:

> `url.parse()` uses a lenient, non-standard algorithm for parsing URL strings. It is prone to security issues such asÂ [host name spoofing](https://hackerone.com/reports/678487)Â and incorrect handling of usernames and passwords. Do not use with untrusted input. CVEs are not issued forÂ `url.parse()`Â vulnerabilities. Use theÂ [WHATWG URL](https://nodejs.org/api/url.html#the-whatwg-url-api)Â API instead.

If you are curious about the performance changes of `url.parse` and `url.resolve`, check out the [State of Node.js Performance 2023 repository](https://github.com/RafaelGSS/state-of-nodejs-performance-2023#url-results).

That said, itâ€™s really interesting to see the results of the new whatwg-url-parse:

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174627/blog/state-of-nodejs-performance-2023/compare-url-16-20-whatwg-bar_wiaczh.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174627/blog/state-of-nodejs-performance-2023/compare-url-16-20-whatwg-bar_wiaczh.png)

Below is a list of URLs used for benchmarking, which were selected based on the benchmark configuration

With the recent upgrade of Ada 2.0 in Node.js 20, itâ€™s fair to say thereâ€™s also a significant improvement when comparing Node.js 18 to Node.js 20:

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174655/blog/state-of-nodejs-performance-2023/compare-url-18-20-whatwg-bar_pocrnv.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174655/blog/state-of-nodejs-performance-2023/compare-url-18-20-whatwg-bar_pocrnv.png)

And the benchmark file is pretty simple:

The only difference is the second parameter that is used as a base when creating/parsing the URL. Itâ€™s also worth mentioning that when a base is passed (_withBase=â€™trueâ€™_), it tends to perform faster than the regular usage (`new URL(data)`). See all the results expanded in [the main repository](https://github.com/RafaelGSS/state-of-nodejs-performance-2023#url-results).

### Buffers

In Node.js, buffers are used to handle binary data. Buffers are a built-in data structure that can be used to store raw binary data in memory, which can be useful when working with network protocols, file system operations, or other low-level operations. Overall, buffers are an important part of Node.js and are used extensively throughout the platform for handling binary data.

For those of you who make use directly or indirectly of Node.js buffers, I have good news (mainly for Node.js 20 early adopters).

Besides improving the performance of `Buffer.from()` Node.js 20 fixed two main regressions from Node.js 18:

*   `Buffer.concat()`

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174695/blog/state-of-nodejs-performance-2023/compare-buffers-16-18-concat-bar_iymlbc.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174695/blog/state-of-nodejs-performance-2023/compare-buffers-16-18-concat-bar_iymlbc.png)

Node.js version 20 has shown significant improvements compared to version 18, and these improvements remain apparent even when compared to version 16:

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174708/blog/state-of-nodejs-performance-2023/compare-buffers-18-20-concat-bar_o2sqom.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174708/blog/state-of-nodejs-performance-2023/compare-buffers-18-20-concat-bar_o2sqom.png)

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174721/blog/state-of-nodejs-performance-2023/compare-buffers-16-20-concat-bar_yffmjf.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174721/blog/state-of-nodejs-performance-2023/compare-buffers-16-20-concat-bar_yffmjf.png)

*   `Buffer.toJSON()`

From Node.js 16 to Node.js 18, a drop of **88%** in the performance of `Buffer.toJSON` was observed:

However, this regression was fixed and improved in Node.js 20 by orders of magnitude!

Therefore, itâ€™s correct to state that Node.js 20 is the fastest version of Node.js in dealing with buffers.

See the full comparison between Node.js 20 and Node.js 18 below:

### Text Encoding and Decoding

TextDecoder and TextEncoder are two JavaScript classes that are part of the Web APIs specification and are available in modern web browsers and Node.js. Together, TextDecoder and TextEncoder provide a simple and efficient way to work with text data in JavaScript, allowing developers to perform various operations involving strings and character encodings.

Decoding and Encoding becomes considerably faster than in Node.js 18. With the addition of **[simdutf](https://github.com/simdutf/simdutf)** for UTF-8 parsing the observed benchmark, results improved by **364%** (an extremely impressive leap) when decoding in comparison to Node.js 16.

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174777/blog/state-of-nodejs-performance-2023/compare-util-16-18-bar_eafprf.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174777/blog/state-of-nodejs-performance-2023/compare-util-16-18-bar_eafprf.png)

Those improvements got even better on Node.js 20, with a performance improvement of **25%** in comparison to Node.js 18. See the full results in the [state-of-nodejs-performance-2023](https://github.com/RafaelGSS/state-of-nodejs-performance-2023#util) repository.

Performance improvements were also observed when comparing _encoding_ methods on Node.js 18. From Node.js 16 to Node.js 18, the `TextEncoder.encodeInto` reached **93.67%** of improvement in the current observation (using `ascii` with a string length of 256):

[![](https://res.cloudinary.com/rafaelgss/image/upload/v1684174830/blog/state-of-nodejs-performance-2023/compare-util-16-18-encode-bar_e0o0fy.png)](https://res.cloudinary.com/rafaelgss/image/upload/v1684174830/blog/state-of-nodejs-performance-2023/compare-util-16-18-encode-bar_e0o0fy.png)

Node.js Bench Operations
------------------------

The benchmarking operations in Node.js have always piqued my curiosity. As someone who enjoys exploring the intricacies of Node.js and its underlying technology, I find it fascinating to delve into the details of these operations, particularly those related to the V8 engine. In fact, I often like to share my findings with others through talks and workshops delivered by [NearForm](https://www.nearform.com/), a company Iâ€™m affiliated with. If youâ€™re interested, you can find more information about my presentations on this topic by [clicking this link](https://rafaelgss.dev/).

In addition, these benchmarks will use the `ops/sec` metric, which basically means the number of operations that were performed in one second. Itâ€™s important to emphasize that this can only mean a very small fraction of your computing time. If you have read my previous article ([Preparing and Evaluating Benchmarks](https://blog.rafaelgss.dev/preparing-and-evaluating-benchmarks)) you should remember the â€˜Evaluating Resultsâ€™ section, where I approach the problem with `ops/sec` in real-world applications â€” if not, you should consider returning to it.

### Parsing Integers

Parsing strings to numbers can be accomplished using either **`+`** or `parseInt(x, 10)`. Previous benchmark results showed that using `+` was faster than `parseInt(x, 10)` in earlier versions of Node.js, as illustrated in the table below:

<table><thead><tr><th>name</th><th>ops/sec</th><th>samples</th></tr></thead><tbody><tr><td>Using parseInt(x, 10) - small number (2 len)</td><td>283,768,532</td><td>91</td></tr><tr><td>Using parseInt(x, 10) - big number (10 len)</td><td>21,307,115</td><td>100</td></tr><tr><td>Using + - small number (2 len)</td><td>849,906,952</td><td>100</td></tr><tr><td>Using + - big number (10 len)</td><td>849,173,336</td><td>97</td></tr></tbody></table>

[Source](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v18.md#parsing-integer)

However, with the release of Node.js 20 and the new V8 version (11.4), both operations have become equivalent in terms of performance, as shown in the updated benchmark results below:

<table><thead><tr><th>name</th><th>ops/sec</th><th>samples</th></tr></thead><tbody><tr><td>Using parseInt(x, 10) - small number (2 len)</td><td>856,413,575</td><td>98</td></tr><tr><td>Using parseInt(x, 10) - big number (10 len)</td><td>856,754,259</td><td>96</td></tr><tr><td>Using + - small number (2 len)</td><td>857,364,191</td><td>98</td></tr><tr><td>Using + - big number (10 len)</td><td>857,511,971</td><td>96</td></tr></tbody></table>

[Source](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v20.md#parsing-integer)

### Super vs This

One of the interesting benchmarks that have changed with the addition of Node.js 20 is the usage of `this` or `super` in classes, as you can see in the example underneath:

The comparison between `super` and `this` in Node.js 18 was producing the following operations per second (ops/sec):

<table><thead><tr><th>name</th><th>ops/sec</th><th>samples</th></tr></thead><tbody><tr><td>Using super</td><td>159,426,608</td><td>96</td></tr><tr><td>Using this</td><td>160,092,440</td><td>91</td></tr></tbody></table>

[Source](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v18.md#super-vs-this)

There isnâ€™t a significant difference between both approaches and on Node.js 20. This statement holds with a slight difference:

<table><thead><tr><th>name</th><th>ops/sec</th><th>samples</th></tr></thead><tbody><tr><td>Using super</td><td>850,760,436</td><td>97</td></tr><tr><td>Using this</td><td>853,619,840</td><td>99</td></tr></tbody></table>

[Source](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v20.md#super-vs-this)

Based on the benchmark results, it appears that there has been a significant increase in performance when using `this` on Node.js 20 compared to Node.js 18. This increase is quite remarkable, with `this` achieving an impressive _853,619,840 ops/sec_ on Node.js 20 compared to only _160,092,440 ops/sec_ on Node.js 18, which is, **433%** better! Apparently, it has the same property access method as a regular object: `obj.property1`. Also, note that both operations were tested in the same dedicated environment. Therefore, itâ€™s unlikely to have occurred by chance.

### Property Access

There are various ways to add properties to objects in JavaScript, each with its own purpose and sometimes ambiguous in nature. As a developer, you may wonder about the efficiency of property access in each of these methods.

The good news is that the nodejs-bench-operations repository includes a comparison of these methods, which sheds light on their performance characteristics. In fact, this benchmarking data reveals that the property access in Node.js 20 has seen significant improvements, particularly when using objects with `writable: true` and `enumerable/configurable: false` properties.

On Node.js 18 the property access (myObj.test) was producing _166,422,265 ops/sec_. However, under the same circumstances, Node.js 20 is producing _857,316,403 ops/sec_! This and other particularities around property access can be found in the following benchmark results:

*   Property getter access [v18](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v18.md#property-getter-access) / [v20](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v20.md#property-getter-access)
*   Property setter access [v18](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v18.md#property-setter-access) / [v20](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v20.md#property-setter-access)
*   Property access after shape transition [v18](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v18.md) / [v20](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v20.md#property-access-after-shape-transition)

### Array.prototype.at

`Array.prototype.at(-1)` is a method that was introduced in the ECMAScript 2021 specification. It allows you to access the last element of an array without knowing its length or using negative indices, which can be a useful feature in certain use cases. In this way, the `at()` method provides a more concise and readable way to access the last element of an array, compared to traditional methods like `array[array.length - 1]`.

On Node.js 18 this access was considerably slower in comparison to `Array[length-1]`:

<table><thead><tr><th>name</th><th>ops/sec</th><th>samples</th></tr></thead><tbody><tr><td>Length = 100 - Array.at</td><td>26,652,680</td><td>99</td></tr><tr><td>Length = 10_000 - Array.at</td><td>26,317,564</td><td>97</td></tr><tr><td>Length = 1_000_000 - Array.at</td><td>27,187,821</td><td>98</td></tr><tr><td>Length = 100 - Array[length - 1]</td><td>848,118,011</td><td>98</td></tr><tr><td>Length = 10_000 - Array[length - 1]</td><td>847,958,319</td><td>100</td></tr><tr><td>Length = 1_000_000 - Array[length - 1]</td><td>847,796,498</td><td>101</td></tr></tbody></table>

[Source](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v18.md#get-the-last-item-of-an-array)

[Since Node.js 19](https://twitter.com/_rafaelgss/status/1619076762088120321), Array.prototype.at is equivalent to the old-fashioned Array[length-1] as the table below suggests:

<table><thead><tr><th>name</th><th>ops/sec</th><th>samples</th></tr></thead><tbody><tr><td>Length = 100 - Array.at</td><td>852,980,778</td><td>99</td></tr><tr><td>Length = 10_000 - Array.at</td><td>854,299,272</td><td>99</td></tr><tr><td>Length = 1_000_000 - Array.at</td><td>853,374,694</td><td>98</td></tr><tr><td>Length = 100 - Array[length - 1]</td><td>854,589,197</td><td>95</td></tr><tr><td>Length = 10_000 - Array[length - 1]</td><td>856,122,244</td><td>95</td></tr><tr><td>Length = 1_000_000 - Array[length - 1]</td><td>856,557,974</td><td>99</td></tr></tbody></table>

[Source](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v20.md#get-the-last-item-of-an-array)

### String.prototype.includes

Most people know that _RegExp_ is very often the source of many bottlenecks in any kind of application. For instance, you might want to check if a certain variable contains `application/json`.And while you can do it in several manners, most of the time you will end up using either:

*   `/application\/json/.test(text)` - RegEx

or

*   `text.includes('application/json')` - String.prototype.includes

What some of you may not know is that `String.prototype.includes` is pretty much as slow as RegExp on Node.js 16.

<table><thead><tr><th>name</th><th>ops/sec</th><th>samples</th></tr></thead><tbody><tr><td>Using includes</td><td>16,056,204</td><td>97</td></tr><tr><td>Using indexof</td><td>850,710,330</td><td>100</td></tr><tr><td>Using RegExp.test</td><td>15,227,370</td><td>98</td></tr><tr><td>Using RegExp.text with cached regex pattern</td><td>15,808,350</td><td>97</td></tr><tr><td>Using new RegExp.test</td><td>4,945,475</td><td>98</td></tr><tr><td>Using new RegExp.test with cached regex pattern</td><td>5,944,679</td><td>100</td></tr></tbody></table>

[Source](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v16.md#string-searching)

However, since Node.js 18 this behavior was _fixed_.

<table><thead><tr><th>name</th><th>ops/sec</th><th>samples</th></tr></thead><tbody><tr><td>Using includes</td><td>856,127,951</td><td>101</td></tr><tr><td>Using indexof</td><td>856,709,023</td><td>98</td></tr><tr><td>Using RegExp.test</td><td>16,623,756</td><td>98</td></tr><tr><td>Using RegExp.text with cached regex pattern</td><td>16,952,701</td><td>99</td></tr><tr><td>Using new RegExp.test</td><td>4,704,351</td><td>95</td></tr><tr><td>Using new RegExp.test with cached regex pattern</td><td>5,660,755</td><td>95</td></tr></tbody></table>

[Source](https://github.com/RafaelGSS/nodejs-bench-operations/blob/main/RESULTS-v18.md#string-searching)

### Crypto.verify

In Node.js, the crypto module provides a set of cryptographic functionalities that can be used for various purposes, such as creating and verifying digital signatures, encrypting and decrypting data, and generating secure random numbers. One of the methods available in this module is `crypto.verify()`, which is used to verify a digital signature generated by the `crypto.sign()` method.

Node.js 14 (End-of-Life) uses OpenSSL 1.x. On Node.js 16 weâ€™ve had the addition of the [QUIC protocol](https://en.wikipedia.org/wiki/QUIC), but still using OpenSSL version 1. However, in Node.js 18 weâ€™ve updated OpenSSL to version 3.x (over QUIC), and a [regression was found](https://github.com/nodejs/performance/issues/72) after Node.js 18 that reduced from 30k ops/sec to 6~7k ops/sec. [As Iâ€™ve mentioned in the tweet](https://twitter.com/_rafaelgss/status/1646498181675458560), itâ€™s very likely to be caused by the new OpenSSL version. Again, our team is looking into it and if you have any insight on this, feel free to comment on the issue: [https://github.com/nodejs/performance/issues/72](https://github.com/nodejs/performance/issues/72).

Node.js performance initiatives
-------------------------------

The Node.js team has always been careful to ensure that its APIs and core functionalities are optimized for speed and resource usage.

In order to further enhance the performance of Node.js, the team has recently [introduced a new strategic initiative called â€˜Performanceâ€™](https://github.com/nodejs/node/blob/HEAD/doc/contributing/strategic-initiatives.md), which is chaired by [Yagiz Nizipli](https://www.yagiz.co/). This initiative is aimed at identifying and addressing performance bottlenecks in the Node.js runtime and core modules, as well as improving the overall performance and scalability of the platform.

In addition to the Performance initiative, there are several other initiatives currently underway that are focused on optimizing different aspects of Node.js. One of these initiatives is the [â€˜Startup Snapshotâ€™ initiative](https://github.com/nodejs/node/issues/35711), which is chaired by [Joyee](https://joyeecheung.github.io/blog/). This initiative is aimed at reducing the startup time of Node.js applications, which is a critical factor in improving the overall performance and user experience of web applications.

Therefore, if you are interested in this subject, consider joining the meetings every other week, and feel free to send a message in the `#nodejs-core-performance` channel on the [OpenJS Foundation Slack](https://openjs-foundation.slack.com/).

### Things to keep an eye on

Besides the strategic initiatives, there are some pull requests that are very likely to have a great impact on the Node.js performance â€” at the moment Iâ€™m writing the below post (it isnâ€™t merged yet):

*   Node.js Errors - [https://github.com/nodejs/node/pull/46648](https://github.com/nodejs/node/pull/46648)

Errors are very expensive to create in Node.js. Itâ€™s very often a source of bottlenecks in Node.js applications. As an example, [I conducted research on the implementation of fetch in Node.js](https://github.com/nodejs/undici/issues/1203#issuecomment-1100969210) (undici) and discovered one of the villains in the Node.js WebStreams implementation is error creation. Hence, by optimizing error objects in Node.js, we can improve the overall efficiency of the platform and reduce the risk of bottlenecks.

*   Pointer compression builds - [https://github.com/nodejs/build/issues/3204](https://github.com/nodejs/build/issues/3204)

Pointer compression is a technique used in computer programming to reduce the memory usage of programs that make use of many pointers. While it doesnâ€™t improve performance directly, it can indirectly improve performance by reducing cache misses and page faults. This certainly [can reduce some infra costs, as described in the issue thread](https://github.com/nodejs/TSC/issues/790#issuecomment-1427005737).

*   Increase default`--max-semi-space-size` - [https://github.com/nodejs/node/pull/47277](https://github.com/nodejs/node/pull/47277)

[An issue was created in March 2022](https://github.com/nodejs/node/issues/42511) suggesting increasing the V8 `max_semi_space_size` with the objective to reduce the Garbage Collection (Scavenge specifically) runs and increasing the overall throughput in the web tooling benchmark. Weâ€™re still evaluating its impact and it may or may not arrive in Node.js 21.

*   bump `highWaterMark` value on Node.js Readable/Writable streams - [https://github.com/nodejs/node/pull/46608](https://github.com/nodejs/node/pull/46608)

This PR increases the default value for `highWaterMark` value in Node.js streams. Itâ€™s expected to perceive a performance improvement in the Node.js stream usage with default options. This PR however, is a `semver-major` change and should arrive on Node.js 21. For a detailed benchmark result, wait for: â€˜State of Node.js Performance 2023 - P2â€™ at the end of the year.

Conclusion
----------

Despite some regressions in the Node.js streams and crypto module, Node.js 20 boasts significant improvements in performance compared to previous versions. Notable enhancements have been observed in JavaScript operations such as property access, URL parsing, buffers/text encoding and decoding, startup/process lifecycle time, and EventTarget, among others.

The Node.js performance team ([nodejs/performance](https://github.com/nodejs/performance)) has expanded its scope, leading to greater contributions in optimizing performance with each new version. This trend indicates that Node.js will continue to become faster over time.

Itâ€™s worth mentioning that the benchmark tests focus on specific operations, which may or may not directly impact your specific use case. Therefore, I strongly recommend reviewing all the benchmark results in the [state-of-nodejs-performance repository](https://github.com/RafaelGSS/state-of-nodejs-performance-2023) and ensuring that these operations align with your business requirements.

Acknowledgments
---------------

I would like to express my sincere gratitude to all the reviewers who took the time to provide valuable feedback on my blog post. Thank you for your time, expertise, and constructive comments.

*   [Vinicius LourenÃ§o](https://twitter.com/vinii_joga10)
*   [Yagiz Nizipli](https://twitter.com/yagiznizipli)
*   [Debadree Chatterjee](https://twitter.com/DebadreeC)
*   [Igor Savin](https://twitter.com/kibertoad)
*   [Paolo Insogna](https://twitter.com/p_insogna)

* * *